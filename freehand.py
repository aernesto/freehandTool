#! /usr/bin/python

'''
Copyright 2012 Lloyd Konneker

This is free software, covered by the GNU General Public License.
'''

'''
Freehand drawing tool.
Input: pointer device (mouse) events.
Output: graphic vector path (lines and splines) which a GUI toolkit renders.
Not a complete app, only a component.
Includes a rudimentary GUI app for testing.
Written in pure Python.

Tags:
- freehand drawing
- computational geometry.
- incremental (dynamic) line tracing.
- Python coroutines.
- pipe of filters.
- GUI toolkit Qt.

Incremental line tracing
========================
Tracing means generating vector graphics from bitmaps.
Incremental, also called dynamic, means generate graphics as a user works,
before the user has completed a stroke (say by mouseReleaseEvent.)
Compare to other freehand tools that draw (not render) pixels until end of tool,
then fit splines to the complete PointerPath and renders the spline.
Here, immediately draw vector graphics (splines and lines.)
Here, look at only a finite tail of the PointerPath.

Goals of incrementality:
- avoid drawing jaggy pixel traces (only to be redrawn later)
- use machine cycles otherwise wasted waiting for pointerEvents

There is a tradeoff: if we spend too much time here, then we fall behind the pointer,
and worse, most GUI toolkits will condense pointer events and only deliver the latest one
(leaving gaps in the input PointerPath).  In other words,  the input will have low resolution.
Then the output suffers, since its quality depends on input resolution.

Filter pipes in Python
======================
This is a series or pipe of filters.
The data between the filters are sequences (streams) of:
- pointer positions, possibly with gaps and possibly with jitter
- pointer positions, without jitter (not implemented)
- pointer turns, between pointer positions not on same axis
- vectors (straight lines) fitting end to end and quaranteed to pass through every PointerPosition (the pixel around it.)
- vectors with adjusted real vertexes (not implemented)
- graphic objects (lines and segments)
- optimized graphic objects (minimal count and minimal error) (not implemented)

The filters are "extended generator" or coroutine or "reverse generators."
Pointer events are pushed (send()) into the pipe and each filter pushes any result to the next filter.
Each filter may maintain history (often just one previous) of its input events,
rolling forward when it recognizes an object that the next filter needs.
The final filter generates finished graphic objects.

potrace
=======
This uses sequence of filters and algorithms from potrace library for tracing bitmap images, by Peter Selinger.
See the potrace paper, it is well written and understandable.

Note some of the filters are optional and this code might not implement them.
See potrace for more description of missing filters.

The main difference to potrace is: potrace input is an image, this input is a PointerPath.

One difference from potrace is that potrace globally finds the best fit.
That is, for a COMPLETE PointerPath, there are many fits, and it would find the best.
Incrementally, we don't have a complete PointerPath,
and we don't have the computing power to incrementally generate a best fit for the partial PointerPath.
We only find the easiest fit, the first one generated.
This could be extended to find a better fit from a set of alternative fits for a short tail of the PointerPath
(where short is defined by how much we can do without lagging the pointer.)
Or you could just use the generated fit as a first approximation, find the best fit, and redraw
(which the user might see as a nudge.)

Another difference from potrace is that potrace generates from continuous paths.
Here the path is generated by the pointer device and may have gaps (if the OS is busy.)
Here detectCorner works despite gaps, i.e. isolates rest of pipe from gaps in the PointerPath. 

Another difference from potrace is that this uses timing.

A property of the potrace algorithm is that it generates cusps for sharp angles on short path segments,
AND ALSO cusps for shallow angles on long path lines.
That is a problem for incremental PointerPath tracing: when user moves the pointer very fast,
it leaves long gaps in the PointerPath, makes for long path lines, and cusps rather than splines.
Also, the generated cusps form a polygon which circumbscribes INSIDE concavities of "real pointer track."
A simple fix MIGHT be to dynamically adjust ALPHAMAX to a value near 4/3 when the pointer is moving very fast.
But it might be a hard limit of implementation in Python: 
there simply is not enough machine resources (in one thread) to do better.
(Another fix might be a threaded implementation.)

Timing
======

The timing of a user's stroke has meaning or intention.
When a user strokes rapidly, they intend a smooth curve.
When a user slows a stroke and turns, they might intend a cusp.
But a slow diagonal generates many PathTurns, which should not generate a cusp.

Ghosting
=======
Since the pipeline lags, ghost a graphic item from last output of pipeline to current PointerPosition.
Otherwise, the drawn graphic separates from the pointer.

Currently ghosting with a straight LinePathElement.
TODO Better to ghost with a pixmap of the pointer track, OR a crude curve (to be refined later.)

Closing the pipeline
====================
Since the pipeline lags, there is code to shut down the pipeline, generating final graphics to current
PointerPosition.

Currently final generated graphic is just a straight line.
TODO better to fit a curve.

Null segments
=============
Early versions generated null segments.  
Null segments added to a QPainterPath have no effect.
The resulting SegmentString seems OK and the algorithm seems robust.

Later versions don't generate null segments.  
An assertion checks that a segment added to a QPainterPath has an effect.
Although it is more code, it is better because it reveals certain situations that
can be handled better, yielding better SegmentString (by a few pixels?)
It is really not a matter of performance:
whether you spend more time discovering null segments,
or whether you call Qt to append a null segment that has no effect,
probably takes the same amount of time.


FUTURE
====
adapt tool to any GUI kit
jitter filter: doesn't seem to be necessary
curve optimization filter: doesn't seem to be necessary
draw raw mouse track as well as smoothed, for testing
Expose other parameters
Generating single spline, instead of (spline, line) for cusp-like?
Generate a  spline at closing?

Naming
======
generator functions are not classes, but I use use upper case leading letter to emphasize
that calling them returns a generator, whose name begins with lower case letter.

Terminology
===========
(I attempt to use separate terms for distinct concepts!)
Pixels have corners (between sides of a square.)
A PointerPosition is usually coordinates of the upper left corner of a pixel.
A PointerPath, often called a stroke, is a sequence of captured PointerPositions,
from a "pointer device", i.e. mouse, pen, or touch.
(But stroke also refers to a graphics operation of rendering with a brush.)
The "real pointer track" is the shape the user drew, not captured when the pointer moves very fast.
PointerPaths have turns (between subpaths on axis.) Called corners in potrace.
A PathLine is between one or more turns.
Consecutive PathLines have a pivot (points between sequential, non-aligned vectors.)
(Sometimes I use line ambiguously to mean: the math concept, a PathLine, or a LinePathElement.)
The output is a PointerTrack, a sequence of graphic vectors.
Here, it is represented by a QPainterPath inside a QGraphicPathItem.
A PointerTrack comprises a sequence of graphic path items (or elements.)
Graphic path items are LinePathElements or SplinePathElements (beziers.)
Graphic path items have end points.
A cusp is a point between two graphic LinePathElements.  Also called a corner in potrace.
A cusp is usually sharp, but not always an acute angle.
A cusp-like is an end point between a graphic LinePathElement and a SplinePathElement.
When a LinePathElement is between two SplinePathElements, one of the cusp-like is usually sharp.
Distinguish between the PointerPath (bitmap coord input) and the PointerTrack (vector output.)



GUI toolkit adaption
====================
As written, FreehandTool uses Qt.
It could be adapted for other toolkits.
From Qt we use:
- QPointF for points and vectors.
- QLineF for lines
- view and scheme with an API for converting global coords to scheme coords
 and for adding graphic items to scheme
- QGraphicPathItem for the generated drawable graphic (comprising line and curve elements),
to represent user's stroke, 
- OR a set of QGraphicItems for lines and segments

Coordinate systems (CS)
=======================
Tool input is a pointer track.
Typically (e.g. Qt) these are in a view CS, and as in a QMouseEvent, are ints.
Caller should convert to floats.
Tool uses float arithmetic.
Tool passes floats to SegmentString.
'''

import sys

# !!! QTime for timing of cusps
# !!! This not depend on QtGui.  SegmentString depends on QtGui.
from PySide.QtCore import QPointF, Qt
from PySide.QtCore import QObject

from segment import LineSegment
from turnGenerator import TurnGeneratorMixin
from lineGenerator import LineGeneratorMixin
from curveGenerator import CurveGeneratorMixin



'''
Generators are mixin behavior.
  
A generator filter is a mixin'ed method of FreeHand class.
A generator method name is capitalized because method *appears* to be a class.
'''
# Need QObject for QTime

class FreehandTool(TurnGeneratorMixin, LineGeneratorMixin, CurveGeneratorMixin, QObject):


  def __init__(self):
    self.turnGenerator = None # Flag, indicates pipe is generating
    # Also attributes: lineGenerator and curveGenerator
    
    # Tool operates on these, but they are None until setSegmentString
    self.pathHeadGhost = None
    self.path = None  
    
    
  def setSegmentString(self, segmentString, pathHeadGhost, scenePosition):
    '''
    Initialization.
    
    Tell tool the SegmentString it should operate upon.
    Caller should add segmentString graphics item to scene.
    Tool starts writing into segmentString after pointerPressEvent().
    '''
    self.path = segmentString
    self.pathHeadGhost = pathHeadGhost
    self.pathHeadGhost.showAt(scenePosition)

    
  def initFilterPipe(self, startPosition):
    ''' 
    Initialize pipe of filters.
    They feed to each other in same order of creation.
     '''
    self.turnGenerator = self.TurnGenerator(startPosition) # call to generator function returns a generator
    self.turnGenerator.send(None) # Execute preamble of generator and pause at first yield
    
    self.lineGenerator = self.LineGenerator(startPosition) 
    self.lineGenerator.send(None) 
    
    self.curveGenerator = self.CurveGenerator(self.nullPathLine(startPosition))
    self.curveGenerator.send(None) 
  
  
  def closeFilterPipe(self):
    '''
    Close generators. 
    They will finally generate SOME of final objects (i.e. turn, PathLine) to current PointerPosition.
    Assume we already received a pointerMoveEvent at same coords of pointerReleaseEvent.
    
    close() is a built-in method of generators.
    
    Closing a generator may cause it to yield, and thus invoke downstream generators in the pipeline.
    Close generators in their order in the pipeline.
    '''
    if self.turnGenerator is not None:  # Ignore race condition: pointerRelease without prior pointerPress
      self.turnGenerator.close()
      self.turnGenerator = None # Flag pipe is closed
      self.lineGenerator.close()
      self.curveGenerator.close()


  def pointerMoveEvent(self, pointerEvent):
    ''' Feed pointerMoveEvent into a pipe. '''
    # Generate if flag indicates pointer button down
    if self.turnGenerator is not None:
      try:
        self.turnGenerator.send(pointerEvent.viewPos)  # Feed pipe
      except StopIteration:
        '''
        While user is moving pointer with pointer button down, we don't expect pipe to stop.
        If programming error stops pipe, quit app so we can see error trace.
        '''
        print "Abnormal pointerMoveEvent, exiting"
        sys.exit()
      else:
        self.pathHeadGhost.updateEnd(pointerEvent.scenePos)
  
  
  def pointerPressEvent(self, pointerEvent):
    ''' 
    Start freehand drawing. 
    '''
    self.initFilterPipe(pointerEvent.viewPos)

  
  def pointerReleaseEvent(self, pointerEvent):
    ''' User has ended freehand drawing. '''
    self.closeFilterPipe()
    self.pathHeadGhost.hide()
    self._createFinalSegment(pointerEvent)
    print "Final segment count", self.path.countSegments()
  
  
  def _createFinalSegment(self, pointerEvent):
    '''
    CurveGenerator only finally draws:
    - to midpoint of current PathLine.
    - OR for a cusp, current PathLine is nullLine (generated MidToEnd)
    
    Add final element to path, a LinePathElement from midpoint to current PointerPosition.
    Note path already ends at the midpoint, don't need to "return" it from close()
    (and close() CANNOT return a value.)
    
    TODO are we sure not leaving PointerTrack one pixel off?
    TODO straight line is crude, should generate a curve
    '''
    
    currenPathEnd = self.path.getEndPointVCS()
    currentPointerPos = pointerEvent.viewPos
    # Only create final segment if pointer was NOT released at exact end of current path 
    # For example when ending on a timed cusp??
    if currenPathEnd != currentPointerPos:
      finalLineSegment = LineSegment(startPoint=currenPathEnd, endPoint=currentPointerPos)
      self.path.appendSegments( [finalLineSegment], segmentCuspness=[False])
  
  
  def keyPressEvent(self, event):
    ''' 
    For testing, simulate a GUI that moves ControlPoints. 
    
    Any key will move a control point (fixed by constant below.)
    If ControlKey is down, will move the control point
    in an alternate mode (moving the control point independently
    versus moving the control point and its related control point together.)
     '''
    # TODO: we don't need this on every keyPress, just the first 
    controlPointSet = self.path.getControlPointSet()
    
    # delta an arbitrary control point

    if event.modifiers() & Qt.ControlModifier:
      alternateMode = True
    else:
      alternateMode = False
    # 8 start anchor of second segment
    # 6 is Direction CP of second seg
    # 7 is the end anchor of second segment
    self.path.moveRelated(controlPoint=controlPointSet[8], 
                          deltaCoordinate=QPointF(5,5), 
                          alternateMode=alternateMode)
    # Result should be visible
  
  